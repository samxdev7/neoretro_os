#include <graphics.h>
#include <conio.h>
#include <string.h>
#include <dos.h>
#include <stdlib.h> /* Para exit() */
#include <stdio.h>  /* Para manejo de archivos */

/* --- CONSTANTES --- */
#define MAX_LINEAS 10
#define MAX_CHARS_POR_LINEA 78 /* Ajustado para ser mas seguro en la pantalla */
#define ESPACIADO_Y 15
#define FILENAME "NOTAS.TXT" /* Nombre del archivo de guardado */

/* Estructura para almacenar las lineas de texto */
typedef struct {
    char texto[MAX_CHARS_POR_LINEA + 5];
} Cadenas;  /* <-- REVISA: Asegurate que el punto y coma (;) este aqui */

/* --- DECLARACIONES DE FUNCIONES --- */
void inicializar_BGI(int *driver, int *modo, char *path);
void limpiar_Pantalla(void);
void dibujar_Texto(int num_lineas, Cadenas lineas[]);
void mostrar_Menu_Status(const char *mensaje);
void guardar_Archivo(Cadenas lineas[], char *nombre_archivo);
void cargar_Archivo(Cadenas lineas[], char *nombre_archivo, int *linea_actual, int *char_actual);

/* Variable global para simplificar el paso a las funciones */
Cadenas lineas[MAX_LINEAS];

/* --- FUNCION PRINCIPAL --- */
int main() {
    int driver = DETECT, modo;
    int i, j; /* i = Linea actual, j = Posicion de caracter actual */
    char c;

    /* Inicializacion del arreglo (buffer de texto) */
    for (i = 0; i < MAX_LINEAS; i++) {
        lineas[i].texto[0] = '\0';
    }

    /* Asegurate que esta ruta sea correcta para tu TC */
    inicializar_BGI(&driver, &modo, "c:\\TC20\\BIN"); 

    i = 0; /* Linea inicial */
    j = 0; /* Posicion de caracter inicial */

    /* Configuracion inicial de la pantalla */
    settextstyle(DEFAULT_FONT, HORIZ_DIR, 1);
    limpiar_Pantalla();
    mostrar_Menu_Status("Bienvenido. Presione F1 para Guardar, F2 para Cargar.");

    while (1) {
        if (kbhit()) {
            c = getch();

            if (c == 0) { /* Indica que se presiono una tecla especial (como F1, F2) */
                c = getch(); /* Obtener el codigo de la tecla especial */

                if (c == 59) { /* F1 (Guardar) */
                    guardar_Archivo(lineas, FILENAME);
                } else if (c == 60) { /* F2 (Cargar) */
                    cargar_Archivo(lineas, FILENAME, &i, &j);
                    dibujar_Texto(MAX_LINEAS, lineas); /* Redibujar despues de cargar */
                }
                /* Si se presiono una F-key, solo redibujar y continuar */
                mostrar_Menu_Status(NULL);
                continue; 
            }

            if (c == 27) break; /* ESC para salir */

            if (c == 13) { /* Enter */
                if (i < MAX_LINEAS - 1) {
                    i++;
                    j = 0;
                }
            }
            else if (c == 8) { /* Backspace */
                if (j > 0) {
                    j--;
                    lineas[i].texto[j] = '\0';
                } else if (i > 0) {
                    /* Mover a la linea anterior */
                    i--;
                    j = strlen(lineas[i].texto);
                    /* Borrar el ultimo caracter de la linea anterior */
                    if (j > 0) {
                         j--;
                         lineas[i].texto[j] = '\0';
                    }
                }
            }
            else if (c >= 32 && c <= 126) { /* Caracteres imprimibles */
                if (j < MAX_CHARS_POR_LINEA) {
                    lineas[i].texto[j] = c;
                    j++;
                    lineas[i].texto[j] = '\0';
                } else if (i < MAX_LINEAS - 1) {
                    /* Salto automatico de linea */
                    i++;
                    j = 0;
                    lineas[i].texto[j] = c;
                    j++;
                    lineas[i].texto[j] = '\0';
                }
            }

            /* REDIBUJAR toda la pantalla despues de cualquier entrada de texto */
            dibujar_Texto(MAX_LINEAS, lineas);
        }
    }

    closegraph();
    return 0;
}

/* --- IMPLEMENTACION DE FUNCIONES --- */

void inicializar_BGI(int *driver, int *modo, char *path) {
    initgraph(driver, modo, path);
    if (graphresult() != grOk) {
        /* Usamos printf porque el entorno grafico fallo */
        printf("Error de inicializacion grafica: %s\n", grapherrormsg(graphresult()));
        exit(1);
    }
}

void limpiar_Pantalla(void) {
    /* Area de texto (todo menos la barra de menu) */
    setfillstyle(SOLID_FILL, WHITE);
    bar(0, 0, getmaxx(), getmaxy() - 30); /* Limpia hasta antes del menu */
    setcolor(BLACK);
}

void mostrar_Menu_Status(const char *mensaje) {
    int max_x = getmaxx();
    int max_y = getmaxy();
    
    /* 1. Dibuja la barra de menu (fondo azul) */
    setfillstyle(SOLID_FILL, BLUE);
    bar(0, max_y - 30, max_x, max_y);
    setcolor(WHITE);

    /* 2. Muestra las opciones */
    outtextxy(10, max_y - 20, "F1: Guardar | F2: Cargar | ESC: Salir");

    /* 3. Muestra el mensaje de estado (si se proporciona) */
    if (mensaje != NULL) {
        /* El mensaje se muestra en el extremo derecho */
        settextjustify(RIGHT_TEXT, TOP_TEXT);
        outtextxy(max_x - 10, max_y - 20, (char *)mensaje);
        settextjustify(LEFT_TEXT, TOP_TEXT); /* Restaurar justificacion */
    }
    setcolor(BLACK); /* Restaurar color de texto principal */
}

void dibujar_Texto(int num_lineas, Cadenas lineas[]) {
    int k; /* <--- CORRECCION C89: Declaracion de la variable k */
    limpiar_Pantalla(); /* Borra solo el area de texto */

    for (k = 0; k < num_lineas; k++) {
        int y_pos = 10 + (k * ESPACIADO_Y);
        outtextxy(10, y_pos, lineas[k].texto);
    }
    mostrar_Menu_Status(NULL); /* Asegura que el menu se redibuje */
}

/* --- FUNCIONES DE ARCHIVO --- */

/**
 * Guarda el contenido del buffer (lineas[]) en un archivo.
 */
void guardar_Archivo(Cadenas lineas[], char *nombre_archivo) {
    FILE *fp;
    int k; /* <--- CORRECCION C89: Declaracion de la variable k */
    
    fp = fopen(nombre_archivo, "w"); /* "w" para escribir (sobrescribir) */
    
    if (fp == NULL) {
        mostrar_Menu_Status("ERROR: No se pudo abrir el archivo para guardar.");
        return;
    }

    for (k = 0; k < MAX_LINEAS; k++) {
        /* Solo guarda las lineas que contienen texto */
        if (strlen(lineas[k].texto) > 0) { 
            fprintf(fp, "%s\n", lineas[k].texto);
        }
    }

    fclose(fp);
    mostrar_Menu_Status("Archivo GUARDADO con exito!");
    delay(2000); /* Mostrar mensaje por 2 segundos */
}

/**
 * Carga el contenido de un archivo en el buffer (lineas[]).
 */
void cargar_Archivo(Cadenas lineas[], char *nombre_archivo, int *linea_actual, int *char_actual) {
    FILE *fp;
    int k; /* <--- CORRECCION C89: Declaracion de la variable k */
    
    fp = fopen(nombre_archivo, "r"); /* "r" para leer */
    
    if (fp == NULL) {
        mostrar_Menu_Status("ERROR: No se encontro el archivo o esta vacio.");
        return;
    }

    /* Limpiar buffer actual antes de cargar */
    for (k = 0; k < MAX_LINEAS; k++) {
        lineas[k].texto[0] = '\0';
    }

    k = 0; /* Inicializar k para el ciclo while */
    /* Leer linea por linea hasta el limite del buffer o fin de archivo */
    while (k < MAX_LINEAS && fgets(lineas[k].texto, MAX_CHARS_POR_LINEA + 5, fp) != NULL) {
        /* Quitar el caracter de nueva linea (\n) que agrega fgets */
        lineas[k].texto[strcspn(lineas[k].texto, "\n")] = '\0';
        k++;
    }

    /* Posicionar el cursor al final del texto cargado */
    *linea_actual = k > 0 ? k - 1 : 0;
    *char_actual = strlen(lineas[*linea_actual].texto);

    fclose(fp);
    mostrar_Menu_Status("Archivo CARGADO con exito!");
    delay(2000); /* Mostrar mensaje por 2 segundos */
}